import java.util.Objects;

public class DoublyLinkedList {
	// Implements a circular doubly-linked list.

	private ListNode2<Nucleotide> head;
	private ListNode2<Nucleotide> tail;
	private int nodeCount;

	// Constructor: creates an empty list
	public DoublyLinkedList() {
		tail = head ;
	}

	// Constructor: creates a list that contains
	// all elements from the array values, in the same order
	public DoublyLinkedList(Nucleotide[] values) {
		tail = head ;
		
		for (int j = 0 ; j < values.length ; j ++)
		{
//			tail.setValue (values[j]) ;
//			nodeCount ++ ;
//			
//			tail.setNext (new ListNode<E> (values [j])) ;
//			tail = tail.getNext () ;
			add(values[j]) ;
		}
	}
	
	public ListNode2<Nucleotide> getHead() {
		return head;
	}
	
	public ListNode2<Nucleotide> getTail() {
		return tail;
	}


	// Returns true if this list is empty; otherwise returns false.
	public boolean isEmpty() {
		return (nodeCount == 0) ;
	}

	// Returns the number of elements in this list.
	public int size() {
		return nodeCount ;
	}

	// Returns true if this list contains an element equal to obj;
	// otherwise returns false.
	public boolean contains(Nucleotide obj) {
		for (ListNode2 <Nucleotide> node = head ; node != null ; node = node.getNext())
		{
			if (Objects.equals(node.getValue(), obj))
			{
				return true ;
			}
		}
		return false ;
	}

	// Returns the index of the first element in equal to obj;
	// if not found, returns -1.
	public int indexOf(Nucleotide obj) {
		int pos = 0 ;
		for (ListNode2 <Nucleotide> node = head ; node != null ; node = node.getNext())
		{
			if (Objects.equals(node.getValue(), obj))
			{
				return pos ;
			}
			pos ++ ;
		}
		return -1 ;
	}

	// Adds obj to this collection.  Returns true if successful;
	// otherwise returns false.
	public boolean add(Nucleotide obj) {
		if (nodeCount == 0)
		{
			head = new ListNode2<Nucleotide> (obj) ;
			tail = head ;
			nodeCount ++ ;
			return true ;
		}
		tail.setNext (new ListNode2<Nucleotide> (obj, tail, null)) ;
//		tail.getNext().setPrevious(tail);
		tail = tail.getNext () ;
		nodeCount ++ ;
		return true ;
	}

	// Removes the first element that is equal to obj, if any.
	// Returns true if successful; otherwise returns false.
	public boolean remove(Nucleotide obj) {
		// if in list
		for (ListNode2 <Nucleotide> node = head ; node != null ; node = node.getNext())
		{
			// check if obj in node is obj
			if (Objects.equals(node.getValue(), obj))
			{
				// if at head, remove node
				if (Objects.equals(node, head))
				{
					if (head.getNext() != null)
						head.getNext().setPrevious(null);
					head = head.getNext() ;
					nodeCount -- ;
					return true ;
				}
				// if at end, remove node
				if (Objects.equals(node, tail))
				{
//					node.setNext(null);
					tail = tail.getPrevious() ;
					tail.setNext(null);
					nodeCount -- ;
					return true ;
				}
				// set previous's next to node next
				node.getPrevious().setNext(node.getNext());
				// set next's previous to node previous
				node.getNext().setPrevious(node.getPrevious()) ;
				nodeCount -- ;
				return true ;
			}
		}
		// if not in list
		return false ;
	}

	// Returns the i-th element.               
	public Nucleotide get(int i) {
		if (i >= nodeCount || i < 0)
			throw new IndexOutOfBoundsException(i) ;
		
		
		ListNode2<Nucleotide> point = head;
		for (int j = 0 ; j < i ; j ++)
		{
			point = point.getNext() ;
		}
		
		return point.getValue() ;
		
	}

	// Replaces the i-th element with obj and returns the old value.
	public Nucleotide set(int i, Nucleotide obj) {
		if (i >= nodeCount || i < 0)
			throw new IndexOutOfBoundsException(i) ;
		
		
		ListNode2<Nucleotide> point = head;
		for (int j = 0 ; j < i ; j ++)
		{
			point = point.getNext() ;
		}
		
		Nucleotide old = point.getValue() ;
		point.setValue(obj);
		return old ;
		
	}

	// Inserts obj to become the i-th element. Increments the size
	// of the list by one.
	public void add(int i, Nucleotide obj) {
		if (i > nodeCount || i < 0)
			throw new IndexOutOfBoundsException(i) ;
		

		// new node
		ListNode2 <Nucleotide> temp = new ListNode2 <Nucleotide> (obj) ;
		
		// if nothing in list
		if (nodeCount == 0 && i == 0)
		{
			temp = new ListNode2 <Nucleotide> (obj) ;
			temp.setNext(null);
			head = temp ;
			tail = head ;
			nodeCount ++ ;
		}
		
		// if start
		else if (i == 0)
		{
			temp.setNext(head);
			head.setPrevious(temp);
			head = temp ;
			nodeCount ++ ;
		}
		// if at end
		else if (i == nodeCount)
		{
//			temp.setNext(new ListNode<E> (null));
			tail.setNext(temp);
			temp.setPrevious(tail);
			tail = tail.getNext() ;
			nodeCount ++ ;
		}
		
		// if within list
		else {
			// get node at
			ListNode2 <Nucleotide> node = head ;
			for (int j = 0 ; j < i ; j ++)
			{
				node = node.getNext() ;
			}
			
			temp.setNext(node);
			temp.setPrevious(node.getPrevious()) ;
			node.getPrevious().setNext(temp);
			node.setPrevious(temp);
			
			nodeCount ++ ;
		}
	}

	// Removes the i-th element and returns its value.
	// Decrements the size of the list by one.
	// special case needed for end
	public Nucleotide remove(int i) {
		
		Nucleotide orig ;
		
		if (i >= nodeCount || i < 0)
			throw new IndexOutOfBoundsException(i) ;
		
		// if only head
		if (nodeCount == 1)
		{
			orig = head.getValue() ;
			head = null ;
			nodeCount -- ;
			return orig ;
		}
		
		// if at head
		else if (i == 0)
		{
			orig = head.getValue() ;
			head = head.getNext() ;
			head.setPrevious(null);
			nodeCount -- ;
			return orig ;
		}
		// if at tail
		else if (i == nodeCount-1)
		{
			orig = tail.getValue() ;
			tail.getPrevious().setNext(null);
			tail = tail.getPrevious() ;
			nodeCount -- ;
			return orig ;
			
		}
		// if within list
		else
		{
			ListNode2 <Nucleotide> temp = head;
			for (int j = 0 ; j < i ; j ++)
			{
				temp = temp.getNext() ;
			}
			orig = temp.getValue() ;
			temp.getPrevious().setNext(temp.getNext());
			temp.getNext().setPrevious(temp.getPrevious());
			nodeCount -- ;
			return orig ;
		}
	}

	// Returns a string representation of this list exactly like that for MyArrayList.
	public String toString() {

		if (nodeCount == 0)
		{
			return "[]" ;
		}
		
		StringBuilder str = new StringBuilder ("[") ;
		
		// how go through listnode
		for (ListNode2 <Nucleotide> node = head ; node != null ; node = node.getNext())
		{
			str.append(node.getValue() + ", ") ;
		}
		return str.substring(0, str.length() - 2) + "]" ;

	}
	
	public String toReverse ()
	{
		StringBuilder str = new StringBuilder ("[") ;
		
		if (nodeCount == 0)
		{
			return "[]" ;
		}
		
		// how go through listnode
		for (ListNode2 <Nucleotide> node = tail ; node != null ; node = node.getPrevious())
		{
			str.append(node.getValue() + ", ") ;
		}
		return str.substring(0, str.length() - 2) + "]" ;
	}
	
	// Like question 7 on the SinglyLinkedList test:
	// Add a "segment" (another list) onto the end of this list
	public void addSegmentToEnd(DoublyLinkedList seg) {
		tail.setNext(seg.getHead());
		seg.getHead().setPrevious(tail);
		tail = seg.getTail() ;
		nodeCount += seg.size() ;
	}
	
	// Like question 8 on the SinglyLinkedList test:
	// You are to remove the next 16 nodes from the list, after the node nodeBefore.
	// (on the test these nodes were assumed to contain CCCCCCCCGGGGGGGG, but here
	// you do not need to assume or check for that)
	public void removeCCCCCCCCGGGGGGGG(ListNode2<Nucleotide> nodeBefore) {
		
		ListNode2<Nucleotide> nodeEnd = nodeBefore ;
		for (int i = 0 ; i <= 16 ; i ++)
		{
			nodeEnd = nodeEnd.getNext() ;
		}
		
		nodeBefore.setNext(nodeEnd);
		if (!Objects.equals(nodeEnd, null))
		{
			nodeEnd.setPrevious(nodeBefore);
		}
		else
		{
			tail = nodeBefore ;
		}
		nodeCount -= 16 ;
	}
	
	// Like question 9 on the SinglyLinkedList test:
	// You are to find and delete the first instance of seg in the list.
	// If seg is not in the list, return false, otherwise return true.
	public boolean deleteSegment(DoublyLinkedList seg) {
		
		ListNode2<Nucleotide> startOfSeg = head ;
		ListNode2<Nucleotide> endOfSeg;
		ListNode2<Nucleotide> segPointer = seg.getHead() ;
		boolean isSeg ;
		
		if (seg.size() > nodeCount)
			return false ;
		
		for (int j = 0 ; j < nodeCount ; j ++)
		{
			endOfSeg = startOfSeg ;
			segPointer = seg.getHead() ;
			isSeg = true ;
			
			for (int k = 0 ; k < seg.size() ; k ++)
			{
				if (!Objects.equals(segPointer.getValue(), endOfSeg.getValue()))
				{
					isSeg = false ;
					break ;
				}
				
				if (endOfSeg.getNext() != null && k + 1 != seg.size())
//				if (k + 1 != seg.size())
					endOfSeg = endOfSeg.getNext() ;
				segPointer = segPointer.getNext() ;
			}
			
			// delete seg if there
			if (isSeg)
			{
				
//				System.out.println("seg head " + startOfSeg.getValue()) ;
//				System.out.println("seg tail " + endOfSeg.getValue()) ;
				
				// if head and tail (if seg == this)
				if (Objects.equals(startOfSeg, head) && Objects.equals(endOfSeg, tail))
				{
					head = null ;
					tail = head ;
				}
				// if head
				else if (Objects.equals(startOfSeg, head))
				{
					head = endOfSeg.getNext() ;
					head.setPrevious (null) ;
				}
				// if tail
				else if (Objects.equals(endOfSeg, tail))
				{
					tail = startOfSeg.getPrevious() ;
					tail.setNext(null);
				}
				// if else
				else
				{
					endOfSeg.getNext().setPrevious(startOfSeg.getPrevious());
					startOfSeg.getPrevious().setNext(endOfSeg.getNext());
				}
				nodeCount-= seg.size() ;
				return true ;
			}
			
			startOfSeg = startOfSeg.getNext() ;
		}
		
		return false ;
	}
	
	// Like question 10 on the SinglyLinkedList test:
	// Delete the last three nodes in the list
	// If there are not enough nodes, return false
	public boolean deleteLastThree() {
		
		if (nodeCount < 3)
			return false ;
		
		if (nodeCount == 3)
		{
			head = null ;
			tail = head ;
			nodeCount -= 3 ;
			return true ;
		}
		
		ListNode2 <Nucleotide> temp = tail ;
		for (int j = 0 ; j < 3 ; j ++)
		{
			temp = temp.getPrevious() ;
		}
		tail = temp ;
		tail.setNext(null);
		nodeCount -= 3 ;
		return true ;
	}

	// Like question 11 on the SinglyLinkedList test:
	// Replaces every node containing "A" with three nodes containing "T" "A" "C"
	public void replaceEveryAWithTAC() {
//		ListNode2 <Nucleotide> temp = head ;
		for (ListNode2 <Nucleotide> temp = head ; temp != null ; temp = temp.getNext())
		{
			if (Objects.equals(temp.getValue(), Nucleotide.A))
			{
				ListNode2 <Nucleotide> tNode = new ListNode2 <Nucleotide> (Nucleotide.T, temp.getPrevious(), temp) ;
				ListNode2 <Nucleotide> cNode = new ListNode2 <Nucleotide> (Nucleotide.C, temp, temp.getNext()) ;
				if (temp.getPrevious() != null)
				{
					temp.getPrevious().setNext(tNode);
				}
				if (temp.getNext() != null)
				{
					temp.getNext().setPrevious(cNode);
				}
				temp.setPrevious(tNode);
				temp.setNext(cNode) ;
				// set head if needed
				if (Objects.equals(head, temp))
					head = temp.getPrevious() ;
				// set tail if needed
				if (Objects.equals(tail, temp))
					tail = temp.getNext() ;
				nodeCount += 2 ;
			}
		}
	}

}